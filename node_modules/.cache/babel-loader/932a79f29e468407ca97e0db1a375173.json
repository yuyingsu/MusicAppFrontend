{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar debug = require('debug')('socket.io-parser');\n\nvar Emitter = require('component-emitter');\n\nvar hasBin = require('has-binary2');\n\nvar binary = require('./binary');\n\nvar isArray = require('isarray');\n\nvar isBuf = require('./is-buffer');\n/**\n * Protocol version.\n *\n * @api public\n */\n\n\nexports.protocol = 4;\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\n\nEncoder.prototype.encode = function (obj, callback) {\n  if ((obj.type === exports.EVENT || obj.type === exports.ACK) && hasBin(obj.data)) {\n    obj.type = obj.type === exports.EVENT ? exports.BINARY_EVENT : exports.BINARY_ACK;\n  }\n\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\n\nfunction encodeAsString(obj) {\n  // first is type\n  var str = '' + obj.type; // attachments if we have them\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  } // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n\n\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  } // immediately followed by the id\n\n\n  if (null != obj.id) {\n    str += obj.id;\n  } // json data\n\n\n  if (null != obj.data) {\n    str += JSON.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\n\nfunction encodeAsBinary(obj, callback) {\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n    buffers.unshift(pack); // add packet info to beginning of data list\n\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n/**\n * Mix in `Emitter` with Decoder.\n */\n\n\nEmitter(Decoder.prototype);\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function (obj) {\n  var packet;\n\n  if (typeof obj === 'string') {\n    packet = decodeString(obj);\n\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {\n      // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow\n\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else {\n      // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  } else if (isBuf(obj) || obj.base64) {\n    // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n\n      if (packet) {\n        // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  } else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\n\nfunction decodeString(str) {\n  var i = 0; // look up type\n\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  } // look up attachments if type binary\n\n\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var buf = '';\n\n    while (str.charAt(++i) !== '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n\n    p.attachments = Number(buf);\n  } // look up namespace (if any)\n\n\n  if ('/' === str.charAt(i + 1)) {\n    p.nsp = '';\n\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      p.nsp += c;\n      if (i === str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  } // look up id\n\n\n  var next = str.charAt(i + 1);\n\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n\n    while (++i) {\n      var c = str.charAt(i);\n\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n\n      p.id += str.charAt(i);\n      if (i === str.length) break;\n    }\n\n    p.id = Number(p.id);\n  } // look up json data\n\n\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\n\nDecoder.prototype.destroy = function () {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\n\nBinaryReconstructor.prototype.takeBinaryData = function (binData) {\n  this.buffers.push(binData);\n\n  if (this.buffers.length === this.reconPack.attachments) {\n    // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n\n  return null;\n};\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\n\nBinaryReconstructor.prototype.finishedReconstruction = function () {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}","map":{"version":3,"sources":["C:/Users/yuyin/onedrive/desktop/MusicappFrontendDeployment/node_modules/socket.io-parser/index.js"],"names":["debug","require","Emitter","hasBin","binary","isArray","isBuf","exports","protocol","types","CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK","Encoder","Decoder","prototype","encode","obj","callback","type","data","encodeAsBinary","encoding","encodeAsString","str","attachments","nsp","id","JSON","stringify","writeEncoding","bloblessData","deconstruction","deconstructPacket","pack","packet","buffers","unshift","removeBlobs","reconstructor","add","decodeString","BinaryReconstructor","reconPack","emit","base64","Error","takeBinaryData","i","p","Number","charAt","error","buf","length","c","next","payload","tryParse","substr","isPayloadValid","parse","e","destroy","finishedReconstruction","binData","push","reconstructPacket","msg"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar hasBin = require('has-binary2');\nvar binary = require('./binary');\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  if ((obj.type === exports.EVENT || obj.type === exports.ACK) && hasBin(obj.data)) {\n    obj.type = obj.type === exports.EVENT ? exports.BINARY_EVENT : exports.BINARY_ACK;\n  }\n\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    str += JSON.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var buf = '';\n    while (str.charAt(++i) !== '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      p.nsp += c;\n      if (i === str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i === str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n"]},"metadata":{},"sourceType":"script"}